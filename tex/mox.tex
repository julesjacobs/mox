\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{fontawesome5}
\usepackage{xcolor}
\mprset{flushleft}
\newcommand{\kw}[1]{\text{\textbf{#1}}}
\newcommand{\Let}[3]{\kw{let}\, #1 = #2\, \kw{in}\, #3}
\newcommand{\Fun}[2]{\kw{fun}\, #1 \Rightarrow #2}
\newcommand{\App}[2]{#1\, #2}
\newcommand{\Pair}[2]{(#1, #2)}
\newcommand{\LetPair}[4]{\kw{let}\, (#1, #2) = #3\, \kw{in}\, #4}
\newcommand{\Inl}[1]{\kw{left}(#1)}
\newcommand{\Inr}[1]{\kw{right}(#1)}
\newcommand{\Match}[5]{\kw{match}\, #1\, \kw{with}\, \Inl{#2} \Rightarrow #3 \mid \Inr{#4} \Rightarrow #5}
\newcommand{\AnnotArrow}[1]{%
  \if\relax\detokenize{#1}\relax
    \to
  \else
    \xrightarrow[\AnnotBelow{#1}]{}
  \fi}
\newcommand{\AnnotBinop}[2]{%
  \if\relax\detokenize{#2}\relax
    #1
  \else
    \underset{\AnnotBelow{#2}}{#1}
  \fi}
\newcommand{\AnnotBelow}[1]{\smash{\raisebox{0.25ex}{$\scriptstyle #1$}}}
\newcommand{\TFun}[3][]{#2 \mathrel{\AnnotArrow{#1}} #3}
\newcommand{\TPair}[3][]{#2 \mathbin{\AnnotBinop{\times}{#1}} #3}
\newcommand{\TSum}[3][]{#2 \mathbin{\AnnotBinop{+}{#1}} #3}
\newcommand{\TUnit}{\kw{unit}}
\newcommand{\TEmpty}{\kw{empty}}
\newcommand{\UnitTerm}{\kw{unit}}
\newcommand{\Absurd}[1]{\kw{absurd}\, #1}
\newcommand{\judge}[3]{#1 \vdash #2 : #3}
\newcommand{\Jud}[2]{\judge{\Gamma}{#1}{#2}}
\newcommand{\leqto}{\mathrel{\leq_{\mathrm{to}}}}
\newcommand{\leqin}{\mathrel{\leq_{\mathrm{in}}}}
\newcommand{\mode}[1]{\textsc{#1}}
\newcommand{\subtype}{\mathrel{\sqsubseteq}}
\newcommand{\Sub}[2]{#1 \subtype #2}
\newcommand{\alias}{\mathrel{\underset{\AnnotBelow{\text{alias}}}{\rightsquigarrow}}}
\newcommand{\Alias}[2]{#1 \alias #2}
\newcommand{\Lock}[2][]{
  \text{\faLock}_{#1}(#2)
}

\newcommand{\jules}[1]{{\textcolor{red}{\textbf{J}: #1}}}

\title{Mox Notes}
\author{Jules Jacobs}
\date{\today}

\begin{document}

\maketitle

\section{Modes}

We distinguish two mode familiesâ€”\emph{past} and \emph{future}.
Each axis is ordered by the conversion relation~$\leqto$ (values that can be coerced ``to'' a weaker mode) and an in-placement relation~$\leqin$ (values that can live ``in'' a surrounding mode).
For future modes the two orders coincide, whereas for past modes the in-placement relation reverses conversion.

\medskip
\noindent\textbf{Past axes ($p$)}
\[
\begin{alignedat}{2}
\text{uniqueness (u):}&\quad \mode{unique} \leqto \mode{aliased}\\
&\quad \mode{aliased} \leqin \mode{unique}\\[0.5ex]
\text{contention (c):}&\quad \mode{uncontended} \leqto \mode{shared} \leqto \mode{contended}\\
&\quad \mode{contended} \leqin \mode{shared} \leqin \mode{uncontended}
\end{alignedat}
\]

\medskip
\noindent\textbf{Future axes ($f$)}
\[
\begin{alignedat}{2}
\text{linearity (l):}&\quad \mode{many} \leqto \mode{once} \\
&\quad \mode{many} \leqin \mode{once}\\[0.5ex]
\text{portability (p):}&\quad \mode{portable} \leqto \mode{non-portable}\\
&\quad \mode{portable} \leqin \mode{non-portable}\\
\text{areality (a):}&\quad \mode{global} \leqto \mode{regional} \leqto \mode{local}\\
&\quad \mode{global} \leqin \mode{regional} \leqin \mode{local}
\end{alignedat}
\]

\jules{It isn't clear that the linearity axis' $\leqin$ relation is useful for anything, at least at the moment.}

\medskip                               
We collect the past modes into the tuple $p = (\text{uniqueness}, \text{contention})$ and the future modes into $f = (\text{areality}, \text{linearity}, \text{portability})$, lifting $\leqto$ and $\leqin$ componentwise.
A mode is then the pair $m = (p, f)$, with both relations lifted again to $m$.

\noindent\emph{Intuition.}
Modes are about \emph{deep} operations on values. For example, the uniqueness and linearity axes are about the operation of creating an alias to a value. Alias creation is deep in the sense that when we alias a data structure, then all its children should also be considered aliased (i.e., there are multiple pointer paths from the stack roots to the element). Uniqueness is about whether the pointer path to it is unique, i.e., whether an aliasing operation has been performed on it in the past, and linearity is about whether we're allowed to perform an aliasing operation on it in the future.

A $\mode{unique}$ly referenced value can be coerced to an $\mode{aliased}$ value -- we simply forget that it was uniquely referenced -- hence $\mode{unique} \leqto \mode{aliased}$. It is also safe to store an aliased value inside a uniquely referenced structure, so $\mode{aliased} \leqin \mode{unique}$. Conversely, it is nonsensical to say a uniquely referenced value is stored in an aliased container, because aliasing is a deep property: if the container is considered aliased, then all its elements are as well.

If an aliasing operation may be performed on a value (mode $\mode{many}$, think ``aliasable''), it is safe to coerce it to a value on which we are not allowed to perform an aliasing operation (mode $\mode{once}$, think ``nonaliasable''), hence $\mode{many} \leqto \mode{once}$.
Conversely, values that we can create aliases to may be safely stored in containers that we are not allowed to create aliases to, hence $\mode{many} \leqin \mode{once}$.
Allowing the converse storage would be unsound: placing a one-time value inside a aliasable container would expose the value to multiple aliases by aliasing the outer container.

In summary, the guarantees along past axes can get weaker as one goes from a container to its elements, and the restrictions along future axes also get weaker as one goes from a container to its elements.
The flipping of the $\leqto$ order stems from the fact that it's safe to \emph{forget} facts about the past whereas it's safe to \emph{add} restrictions on the future.


\section{Expressions}

\begin{flalign*}
e &\mathrel{::=} {} && \text{-- expressions} &&\\
 & \mid x \mid \Let{x}{e_1}{e_2} && \text{-- variables} &&\\
 & \mid \UnitTerm \mid \Absurd{e}&& \text{-- unit and empty} &&\\
 & \mid \App{e_1}{e_2} \mid \Fun{x}{e} && \text{-- functions} &&\\
 & \mid \Pair{e_1}{e_2} \mid \LetPair{x_1}{x_2}{e_1}{e_2} && \text{-- pairs} &&\\
 & \mid \Inl{e} \mid \Inr{e} && \text{-- sums} &&\\
 & \mid \Match{e}{x_1}{e_1}{x_2}{e_2} && &&
\end{flalign*}

\bigskip


\section{Types}

\begin{flalign*}
\tau &\mathrel{::=} {} &&&&\\
 & \mid \TUnit \mid \TEmpty && \text{-- unit and empty} &&\\
 & \mid \TFun[f]{\tau_1}{\tau_2} && \text{-- functions} &&\\
 & \mid \TPair[s]{\tau_1}{\tau_2} && \text{-- pairs} &&\\
 & \mid \TSum[s]{\tau_1}{\tau_2} && \text{-- sums} &&
\end{flalign*}

\section{Notation}

Function arrows carry a function (future) mode annotation~$f$, drawing from the future lattice so $f = (\text{areality}, \text{linearity}, \text{portability})$.
Storage annotations~$s$ appear on products and sums, recording how elements are kept with $s = (\text{uniqueness}, \text{areality})$.
We write $\hat{f}$ for the embedding of $f$ into the full mode lattice (past component~$\bot_{\mathrm{in}}$, future component~$f$) and $\hat{s}$ for the embedding of $s$.

\bigskip

\section{Kinding Rules}

We write $\tau : m$ to state that type $\tau$ is well-formed at mode $m$.
Write $m \sqcap \hat{s}$ for the meet of $m$ with $\hat{s}$ in the $\leqin$-lattice; it leaves the future components unchanged and meets the uniqueness and areality components with those recorded by $s$.
Here $\top_{\mathrm{in}}$ denotes the greatest mode with respect to $\leqin$.

\begin{mathpar}
\inferrule
  {\ }
  {\TUnit : m}
\and
\inferrule
  {\ }
  {\TEmpty : m}
\and
\inferrule
  {\hat{f} \leqin m \\ \tau_1 : \top_{\mathrm{in}} \\ \tau_2 : \top_{\mathrm{in}}}
  {\TFun[f]{\tau_1}{\tau_2} : m}
\and
\inferrule
  {\hat{s} \leqin m \\ \tau_1 : m \sqcap \hat{s} \\ \tau_2 : m \sqcap \hat{s}}
  {\TPair[s]{\tau_1}{\tau_2} : m}
\and
\inferrule
  {\hat{s} \leqin m \\ \tau_1 : m \sqcap \hat{s} \\ \tau_2 : m \sqcap \hat{s}}
  {\TSum[s]{\tau_1}{\tau_2} : m}
\end{mathpar}

We will omit the annotations when they are not needed.

\bigskip

\section{Typing Rules}

Typing judgments use linear contexts: $\Gamma_1 \uplus \Gamma_2$ denotes a partition of the context into disjoint subcontexts, and $\emptyset$ is the empty context.

\bigskip

\textit{Variables}
\begin{mathpar}
\inferrule
  {\ }
  {\judge{x : \tau}{x}{\tau}}
\and
\inferrule
  {\judge{\Gamma_1}{e_1}{\tau_1} \\ \judge{\Gamma_2, x : \tau_1}{e_2}{\tau_2}}
  {\judge{\Gamma_1 \uplus \Gamma_2}{\Let{x}{e_1}{e_2}}{\tau_2}}
\end{mathpar}

\vspace{0.5em}\textit{Unit and Empty}
\begin{mathpar}
\inferrule
  {\ }
  {\judge{\emptyset}{\UnitTerm}{\TUnit}}
\and
\inferrule
  {\judge{\Gamma}{e}{\TEmpty}}
  {\judge{\Gamma}{\Absurd{e}}{\tau}}
\end{mathpar}

\vspace{0.5em}\textit{Functions}
\begin{mathpar}
\inferrule
  {\judge{\Lock[f]{\Gamma}, x : \tau_1}{e}{\tau_2}}
  {\judge{\Gamma}{\Fun{x}{e}}{\TFun[f]{\tau_1}{\tau_2}}}
\and
\inferrule
  {\judge{\Gamma_1}{e_1}{\TFun{\tau_1}{\tau_2}} \\ \judge{\Gamma_2}{e_2}{\tau_1}}
  {\judge{\Gamma_1 \uplus \Gamma_2}{\App{e_1}{e_2}}{\tau_2}}
\end{mathpar}

\vspace{0.5em}\textit{Pairs}
\begin{mathpar}
\inferrule
  {\judge{\Gamma_1}{e_1}{\tau_1} \\ \judge{\Gamma_2}{e_2}{\tau_2}}
  {\judge{\Gamma_1 \uplus \Gamma_2}{\Pair{e_1}{e_2}}{\TPair{\tau_1}{\tau_2}}}
\and
\inferrule
  {\judge{\Gamma_1}{e_1}{\TPair{\tau_1}{\tau_2}} \\ \judge{\Gamma_2, x_1 : \tau_1, x_2 : \tau_2}{e_2}{\tau}}
  {\judge{\Gamma_1 \uplus \Gamma_2}{\LetPair{x_1}{x_2}{e_1}{e_2}}{\tau}}
\end{mathpar}

\vspace{0.5em}\textit{Sums}
\begin{mathpar}
\inferrule
  {\judge{\Gamma}{e}{\tau_1}}
  {\judge{\Gamma}{\Inl{e}}{\TSum{\tau_1}{\tau_2}}}
\and
\inferrule
  {\judge{\Gamma}{e}{\tau_2}}
  {\judge{\Gamma}{\Inr{e}}{\TSum{\tau_1}{\tau_2}}}
\and
\inferrule
  {\judge{\Gamma_0}{e}{\TSum{\tau_1}{\tau_2}} \\ \judge{\Gamma_1, x_1 : \tau_1}{e_1}{\tau} \\ \judge{\Gamma_1, x_2 : \tau_2}{e_2}{\tau}}
  {\judge{\Gamma_0 \uplus \Gamma_1}{\Match{e}{x_1}{e_1}{x_2}{e_2}}{\tau}}
\end{mathpar}

\vspace{0.5em}\textit{Subsumption}
\begin{mathpar}
\inferrule
  {\judge{\Gamma}{e}{\tau_1} \\ \Sub{\tau_1}{\tau_2}}
  {\judge{\Gamma}{e}{\tau_2}}
\end{mathpar}

\vspace{0.5em}\textit{Aliasing}
\begin{mathpar}
\inferrule
  {\judge{\Gamma, x : \tau'_1, x : \tau'_1}{e}{\tau_2} \\ \Alias{\tau_1}{\tau'_1}}
  {\judge{\Gamma, x : \tau_1}{e}{\tau_2}}
\end{mathpar}

\section{Subtyping Rules}

\textit{Base}
\begin{mathpar}
\inferrule
  {\ }
  {\Sub{\TUnit}{\TUnit}}
\and
\inferrule
  {\ }
  {\Sub{\TEmpty}{\TEmpty}}
\end{mathpar}

\vspace{0.5em}\textit{Functions}
\begin{mathpar}
\inferrule
  {\Sub{\tau_1'}{\tau_1} \\ \Sub{\tau_2}{\tau_2'} \\ f_1 \leqto f_2}
  {\Sub{\TFun[f_1]{\tau_1}{\tau_2}}{\TFun[f_2]{\tau_1'}{\tau_2'}}}
\end{mathpar}

\vspace{0.5em}\textit{Products and Sums}
\begin{mathpar}
\inferrule
  {\Sub{\tau_1}{\tau_1'} \\ \Sub{\tau_2}{\tau_2'} \\ s_1 \leqto s_2}
  {\Sub{\TPair[s_1]{\tau_1}{\tau_2}}{\TPair[s_2]{\tau_1'}{\tau_2'}}}
\and
\inferrule
  {\Sub{\tau_1}{\tau_1'} \\ \Sub{\tau_2}{\tau_2'} \\ s_1 \leqto s_2}
  {\Sub{\TSum[s_1]{\tau_1}{\tau_2}}{\TSum[s_2]{\tau_1'}{\tau_2'}}}
\end{mathpar}

\section{Aliasing}

The judgment $\Alias{\tau}{\tau'}$ records that aliasing $\tau$ is allowed and yields type $\tau'$.

\bigskip

\textit{Base}
\begin{mathpar}
\inferrule
  {\ }
  {\Alias{\TUnit}{\TUnit}}
\and
\inferrule
  {\ }
  {\Alias{\TEmpty}{\TEmpty}}
\end{mathpar}

\vspace{0.5em}\textit{Functions}
\begin{mathpar}
\inferrule
  {f = (a, \mode{many}, p)}
  {\Alias{\TFun[f]{\tau_1}{\tau_2}}{\TFun[f]{\tau_1}{\tau_2}}}
\end{mathpar}

\vspace{0.5em}\textit{Products and Sums}
\begin{mathpar}
\inferrule
  {\Alias{\tau_1}{\tau_1'} \\ \Alias{\tau_2}{\tau_2'} \\ s = (u, a)}
  {\Alias{\TPair[s]{\tau_1}{\tau_2}}{\TPair[(\mode{aliased}, a)]{\tau_1'}{\tau_2'}}}
\and
\inferrule
  {\Alias{\tau_1}{\tau_1'} \\ \Alias{\tau_2}{\tau_2'} \\ s = (u, a)}
  {\Alias{\TSum[s]{\tau_1}{\tau_2}}{\TSum[(\mode{aliased}, a)]{\tau_1'}{\tau_2'}}}
\end{mathpar}

\section{Locking}

Typing a closure of type $\TFun[f]{\tau_1}{\tau_2}$ applies a lock to the ambient context, written $\Lock[f]{\Gamma}$. 
Here $f=(\text{areality}, \text{linearity}, \text{portability})$ tracks the function mode. 
The lock records which bindings remain accessible inside the closure and how their modes are weakened so that the body can run safely.
We define the operation structurally on contexts.
\begin{align*}
(x:\tau') \in \Lock[f]{\Gamma} &\iff (x:\tau) \in \Gamma \ \land\ \Lock[f]{\tau} = \tau'\\
\Lock[(l_2,o_2,p_2)]{\Gamma, x :-} &= \Lock[(l_2,o_2,p_2)]{\Gamma}, x :-\\
\Lock[(l_2,o_2,p_2)]{\Gamma, x : \tau @ (l_1,o_1,u_1,p_1,c_1)} &=
  \begin{cases}
    \Lock[(l_2,o_2,p_2)]{\Gamma}, x : \tau @ (l_1,o_1, u_1 \lor o_2^{\dagger}, p_1, c_1 \lor p_2^{\dagger}) & l_1 \leqto l_2,\ o_1 \leqto o_2,\ p_1 \leqto p_2,\\
    \Lock[(l_2,o_2,p_2)]{\Gamma}, x :- & \text{otherwise.}
  \end{cases}
\end{align*}
\begin{align*}
  \Lock[f]{\TUnit} &\ =\  \TUnit\\
  \Lock[f]{\TEmpty} &\ =\ \TEmpty\\
  \Lock[f]{\TFun[f']{\tau_1}{\tau_2}} &\ =\ \TFun[f']{\tau_1}{\tau_2} \quad\text{ if }\quad f \leqto f'\\
  \Lock[f]{\TPair[s]{\tau_1}{\tau_2}} &\ =\ \TPair[s']{\Lock[f]{\tau_1}}{\Lock[f]{\tau_2}} \quad\text{ where }\quad s' = s \sqcup f^\dagger\\
  \Lock[f]{\TSum[s]{\tau_1}{\tau_2}} &\ =\ \TSum[s']{\Lock[f]{\tau_1}}{\Lock[f]{\tau_2}} \quad\text{ where }\quad s' = s \sqcup f^\dagger\\
  \Lock[f]{\tau} &\ =\ \bot \quad\text{ otherwise}
\end{align*}
The dagger map translates closure capabilities into the weakening applied to captured bindings:
\[
\begin{aligned}
\mode{once}^{\dagger} &= \mode{unique}\\
\mode{many}^{\dagger} &= \mode{aliased}\\
\mode{non-portable}^{\dagger} &= \mode{uncontended}\\
\mode{portable}^{\dagger} &= \mode{contended}\\
(a,l,p)^\dagger &= (l^\dagger, p^\dagger)
\end{aligned}
\]

Intuitively, a $\mode{many}$ closure can only reuse captured data as $\mode{aliased}$, and a $\mode{portable}$ closure forces captured bindings to be $\mode{contended}$.

\section{Desiderata}

\begin{enumerate}
  \item Borrowing
  \item Mode polymorphism
  \item Mutable references \& Fork
  \item Algebraic data types
  \item Type inference
  \item Modules \& abstract types
  \item Fine grained uniquness analysis
\end{enumerate}

\end{document}
