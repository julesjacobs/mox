let r = ref unit in r
> (ref[c=uncontended] unit)

let r = ref unit in !r
> unit

let r = ref unit in r := unit
> unit

let r = ref unit in fork (r := unit)
> error: relation became empty

let r = ref unit in fork (let x = !r in unit)
> error: relation became empty

let r = ref unit in 
let g = fun x => r := x in
g unit
> unit

(* CR jujacobs: bug! *)
let r = ref unit in 
let g = fun x => r := x in
fork (g unit)
> unit

(* CR jujacobs: bug! *)
ref unit : ref unit
> error: outer_equiv: not equivalent

(* CR jujacobs: bug! *)
ref unit : ref[uncontended] unit
> error: outer_equiv: not equivalent

(* CR jujacobs: bug! *)
ref unit : ref[contended] unit
> error: outer_equiv: not equivalent

let r = ref unit in
(fun x => r := x) : unit ->[portable] unit
> (unit ->[a=global l=many p=portable] unit)

let f = (fun x => x) : unit ->[nonportable] unit in
f : unit ->[portable] unit
> error: relation became empty

let f = (fun x => x) : unit ->[portable] unit in
f : unit ->[nonportable] unit
> (unit ->[a=global l=many p=nonportable] unit)

let x = $(unit, unit) in 
fork (let (a,b) = x in a)
> error: relation became empty

let r = ref (unit, unit) in
let x = !r in 
let! (a,b) = x in unit
> unit

ref $(unit, unit)
> error: relation became empty

let r = ref left(unit) in
let x = (region
  let y = $right(unit) in
  r := y) in
!r
> error: relation became empty
