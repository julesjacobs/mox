let r = ref unit in r
> (ref[c=uncontended u=unique] unit)

let r = ref unit in !r
> unit

let r = ref unit in r := unit
> unit

let r = ref unit in fork (r := unit)
> unit

let r = ref unit in fork (let x = !r in unit)
> unit

let r = ref unit in 
let g = fun x => r := x in
g unit
> unit

let r = ref unit in 
let g = fun x => r := x in
fork (g unit)
> unit

ref unit : ref unit
> (ref[c=uncontended u=aliased] unit)

ref unit : ref[uncontended] unit
> (ref[c=uncontended u=aliased] unit)

ref unit : ref[contended] unit
> (ref[c=contended u=aliased] unit)

let r = ref unit in
(fun x => r := x) : unit ->[portable] unit
> error: mode solver detected portability inconsistency

let f = fun x => x in
let g = f : unit ->[portable] unit in
(f, g)
> ((unit ->[a=global r=r3 l=many p=portable] unit) *[u=u1 a=a1 r=r2] (unit ->[a=global r=r1 l=many p=portable] unit))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
>   r3 ∈ [0, inf]
> mode rels
>   r2-r3 <= 0
>   r1-r3 <= 0
>   r1-r2 ∈ [0, inf]

let f = (fun x => x) : unit ->[nonportable] unit in
f : unit ->[portable] unit
> error: mode solver detected portability inconsistency

let f = (fun x => x) : unit ->[portable] unit in
f : unit ->[nonportable] unit
> (unit ->[a=global r=r1 l=many p=nonportable] unit)
> mode vars
>   r1 ∈ [0, inf]

let x = $(unit, unit) in 
fork (let (a,b) = x in a)
> unit

let r = ref (unit, unit) in
let x = !r in 
let! (a,b) = x in unit
> error: mode solver detected uniqueness inconsistency

ref $(unit, unit)
> (ref[c=uncontended u=unique] (unit *[u=aliased a=global r=0] unit))

let r = ref left(unit) in
let x = (region
  let y = $right(unit) in
  r := y) in
!r
> (unit +[u=aliased a=global r=0] unit)

let r = ref unit in 
let s = (r, r) in 
r := unit
> unit

let r = ref unit in (r,r)
> ((ref[c=c1 u=aliased] unit) *[u=u1 a=a1 r=r1] (ref[c=c1 u=aliased] unit))
> mode vars
>   c1 ∈ {contended, shared, uncontended}
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}

let r1 = ref unit in 
let r2 = ref unit in 
(r1, r2)
> ((ref[c=uncontended u=unique] unit) *[u=unique a=a1 r=r1] (ref[c=uncontended u=unique] unit))
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}

let r = ref 1 in
let h = fun x => r := x in
fork (h 2) 
> unit

let r = ref 1 in
let h = fun x => r := x in
let _ = fork (h 2) in h 3
> error: mode solver detected portability inconsistency
