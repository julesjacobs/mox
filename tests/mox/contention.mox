let r = ref unit in r
> (ref[c=uncontended] unit)

let r = ref unit in !r
> unit

let r = ref unit in r := unit
> unit

let r = ref unit in fork (r := unit)
> error: relation became empty

let r = ref unit in fork (let x = !r in unit)
> error: relation became empty

let r = ref unit in 
let g = fun x => r := x in
g unit
> unit

let r = ref unit in 
let g = fun x => r := x in
fork (g unit)
> error: relation became empty

(* CR jujacobs: bug! *)
ref unit : ref unit
> (ref[c=uncontended] unit)

(* CR jujacobs: bug! *)
ref unit : ref[uncontended] unit
> (ref[c=uncontended] unit)

(* CR jujacobs: bug! *)
ref unit : ref[contended] unit
> (ref[c=contended] unit)

let r = ref unit in
(fun x => r := x) : unit ->[portable] unit
> error: relation became empty

let f = fun x => x in
let g = f : unit ->[portable] unit in
(f, g)
> ((unit ->[a=global l=many p=portable] unit) *[u=u1 a=a1] (unit ->[a=global l=many p=portable] unit))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}

let f = (fun x => x) : unit ->[nonportable] unit in
f : unit ->[portable] unit
> error: relation became empty

let f = (fun x => x) : unit ->[portable] unit in
f : unit ->[nonportable] unit
> (unit ->[a=global l=many p=nonportable] unit)

let x = $(unit, unit) in 
fork (let (a,b) = x in a)
> error: relation became empty

let r = ref (unit, unit) in
let x = !r in 
let! (a,b) = x in unit
> error: relation became empty

ref $(unit, unit)
> error: relation became empty

let r = ref left(unit) in
let x = (region
  let y = $right(unit) in
  r := y) in
!r
> error: relation became empty

(* CR jujacobs: bug! *)
let r = ref unit in 
let s = (r, r) in 
r := unit
> error: relation became empty

(* Bug! Sharing the ref makes it contended, which is wrong! *)
let r = ref unit in (r,r)
> ((ref[c=contended] unit) *[u=u1 a=a1] (ref[c=contended] unit))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}

(* Two separate refs keep it uncontended, which is correct!  So the problem is really sharing. *)
let r1 = ref unit in 
let r2 = ref unit in 
(r1, r2)
> ((ref[c=uncontended] unit) *[u=u1 a=a1] (ref[c=uncontended] unit))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
