unit
> unit

let x = unit in x
> unit

borrow x = unit for y = x in y
> unit

borrow x = (unit, unit) for y = x in y
> (unit *[u=aliased a=global r=r1] unit)
> mode vars
>   r1 ∈ [0, inf]

borrow x = ((fun y => y) : (unit ->[once] unit)) for y = x in y
> error: mode solver detected linearity inconsistency

let pair = (unit, unit) in pair
> (unit *[u=u1 a=a1 r=r1] unit)
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}

left(unit)
> (unit +[u=u1 a=a1 r=r1] 'a)
> where
>   'a in {u=u2; c=c1; l=l1; p=p1; a=a2; r=r2}
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
>   r2 ∈ [0, inf]
>   a2 ∈ {borrowed, global}
>   p1 ∈ {nonportable, portable}
>   l1 ∈ {many, never, once}
>   c1 ∈ {contended, shared, uncontended}
>   u2 ∈ {aliased, unique}
> mode rels
>   (u2,u1) ∉ {(unique,aliased)}
>   (a2,a1) ∉ {(borrowed,global)}
>   r1-r2 <= 0

right(unit)
> ('a +[u=u1 a=a1 r=r1] unit)
> where
>   'a in {u=u2; c=c1; l=l1; p=p1; a=a2; r=r2}
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
>   r2 ∈ [0, inf]
>   a2 ∈ {borrowed, global}
>   p1 ∈ {nonportable, portable}
>   l1 ∈ {many, never, once}
>   c1 ∈ {contended, shared, uncontended}
>   u2 ∈ {aliased, unique}
> mode rels
>   (u2,u1) ∉ {(unique,aliased)}
>   (a2,a1) ∉ {(borrowed,global)}
>   r1-r2 <= 0

fun x => x
> ('a ->[a=a1 r=r1 l=l1 p=p1] 'a)
> mode vars
>   p1 ∈ {nonportable, portable}
>   l1 ∈ {many, never, once}
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}

(fun x => x) unit
> unit

ref unit
> (ref[c=uncontended] unit)

let r = ref unit in !r
> unit

let r = ref unit in r := unit
> unit

region unit
> unit

match left(unit) with left(x) => x | right(y) => unit
> unit

let (a,b) = (unit, unit) in a
> unit

(fun x => x) : unit -> unit
> (unit ->[a=global r=r1 l=many p=nonportable] unit)
> mode vars
>   r1 ∈ [0, inf]

let r = ref unit in let alias = r in alias
> (ref[c=uncontended] unit)

let r = ref unit in let g = fun x => r := x in g unit
> unit

let r = ref unit in fork (r := unit)
> error: mode solver detected contention inconsistency

let r = ref unit in fork (let x = !r in x)
> error: mode solver detected contention inconsistency

let x = $(unit, unit) in x
> (unit *[u=u1 a=a1 r=0] unit)
> mode vars
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}

stack (unit, unit)
> error: Unbound variable stack

let! (a,b) = $(unit, unit) in a
> unit

match left(unit) with left(x) => left(x) | right(y) => right(y)
> (unit +[u=u1 a=a1 r=r1] 'a)
> where
>   'c <= 'b
>   'c in {u=u2; c=c1; l=l1; p=p1; a=a2; r=r2}
>   'b <= 'a
>   'b in {u=u3; c=c2; l=l2; p=p2; a=a3; r=r3}
>   'b in {u=u4; c=c3; l=l3; p=p3; a=a4; r=r4}
>   'd <= 'a
>   'd in {u=u5; c=c4; l=l4; p=p4; a=a5; r=r5}
>   'a in {u=u6; c=c5; l=l5; p=p5; a=a6; r=r6}
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
>   r2 ∈ [0, inf]
>   a2 ∈ {borrowed, global}
>   p1 ∈ {nonportable, portable}
>   l1 ∈ {many, never, once}
>   c1 ∈ {contended, shared, uncontended}
>   u2 ∈ {aliased, unique}
>   r3 ∈ [0, inf]
>   a3 ∈ {borrowed, global}
>   p2 ∈ {nonportable, portable}
>   l2 ∈ {many, never, once}
>   c2 ∈ {contended, shared, uncontended}
>   u3 ∈ {aliased, unique}
>   r4 ∈ [0, inf]
>   a4 ∈ {borrowed, global}
>   p3 ∈ {nonportable, portable}
>   l3 ∈ {many, never, once}
>   c3 ∈ {contended, shared, uncontended}
>   u4 ∈ {aliased, unique}
>   r5 ∈ [0, inf]
>   a5 ∈ {borrowed, global}
>   p4 ∈ {nonportable, portable}
>   l4 ∈ {many, never, once}
>   c4 ∈ {contended, shared, uncontended}
>   u5 ∈ {aliased, unique}
>   r6 ∈ [0, inf]
>   a6 ∈ {borrowed, global}
>   p5 ∈ {nonportable, portable}
>   l5 ∈ {many, never, once}
>   c5 ∈ {contended, shared, uncontended}
>   u6 ∈ {aliased, unique}
> mode rels
>   (u6,u1) ∉ {(unique,aliased)}
>   (a6,a1) ∉ {(borrowed,global)}
>   (a5,a1) ∉ {(borrowed,global)}
>   (a3,a1) ∉ {(borrowed,global)}
>   r1-r6 <= 0
>   r1-r5 <= 0
>   r1-r3 <= 0

ref unit : ref unit
> (ref[c=uncontended] unit)

ref unit : ref[contended] unit
> (ref[c=contended] unit)

let r = ref unit in (r : ref[contended] unit)
> (ref[c=contended] unit)

let r = ref unit in let f = fun x => r := x in fork (f unit)
> error: mode solver detected portability inconsistency

let r = ref unit in fork (let g = fun x => x in g unit)
> unit

let r = ref unit in (fun x => !r) unit
> unit

let r = ref unit in (fun f => f unit) (fun _ => r := unit)
> unit

fork unit
> unit

let shared = ref unit in (shared, shared)
> ((ref[c=c1] unit) *[u=u1 a=a1 r=r1] (ref[c=c1] unit))
> mode vars
>   c1 ∈ {contended, shared, uncontended}
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}

let shared = ref unit in let alias = shared in (shared, alias)
> ((ref[c=c1] unit) *[u=u1 a=a1 r=r1] (ref[c=c1] unit))
> mode vars
>   c1 ∈ {contended, shared, uncontended}
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}

let shared = (unit, unit) in (fun f => f shared, fun g => g shared)
> ((((unit *[u=aliased a=a7 r=r7] unit) ->[a=a6 r=r6 l=l4 p=p4] 'd) ->[a=a5 r=r5 l=l3 p=p3] 'c) *[u=u1 a=a4 r=r4] (((unit *[u=aliased a=a3 r=r3] unit) ->[a=a2 r=r2 l=l2 p=p2] 'b) ->[a=a1 r=r1 l=l1 p=p1] 'a))
> where
>   'd <= 'c
>   'b <= 'a
> mode vars
>   p1 ∈ {nonportable, portable}
>   l1 ∈ {many, once}
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   p2 ∈ {nonportable, portable}
>   l2 ∈ {many, once}
>   r2 ∈ [0, inf]
>   a2 ∈ {borrowed, global}
>   r3 ∈ [0, inf]
>   a3 ∈ {borrowed, global}
>   r4 ∈ [0, inf]
>   a4 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
>   p3 ∈ {nonportable, portable}
>   l3 ∈ {many, once}
>   r5 ∈ [0, inf]
>   a5 ∈ {borrowed, global}
>   p4 ∈ {nonportable, portable}
>   l4 ∈ {many, once}
>   r6 ∈ [0, inf]
>   a6 ∈ {borrowed, global}
>   r7 ∈ [0, inf]
>   a7 ∈ {borrowed, global}
> mode rels
>   (a5,a4) ∉ {(borrowed,global)}
>   r4-r5 <= 0
>   r1-r4 ∈ [0, inf]

let shared = ((unit, unit) : (unit *[unique] unit)) in (fun f => f shared, fun g => g shared)
> ((((unit *[u=aliased a=a7 r=r7] unit) ->[a=a6 r=r6 l=l4 p=p4] 'd) ->[a=a5 r=r5 l=l3 p=p3] 'c) *[u=u1 a=a4 r=r4] (((unit *[u=aliased a=a3 r=r3] unit) ->[a=a2 r=r2 l=l2 p=p2] 'b) ->[a=a1 r=r1 l=l1 p=p1] 'a))
> where
>   'd <= 'c
>   'b <= 'a
> mode vars
>   p1 ∈ {nonportable, portable}
>   l1 ∈ {many, once}
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   p2 ∈ {nonportable, portable}
>   l2 ∈ {many, once}
>   r2 ∈ [0, inf]
>   a2 ∈ {borrowed, global}
>   r3 ∈ [0, inf]
>   a3 ∈ {borrowed, global}
>   r4 ∈ [0, inf]
>   a4 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
>   p3 ∈ {nonportable, portable}
>   l3 ∈ {many, once}
>   r5 ∈ [0, inf]
>   a5 ∈ {borrowed, global}
>   p4 ∈ {nonportable, portable}
>   l4 ∈ {many, once}
>   r6 ∈ [0, inf]
>   a6 ∈ {borrowed, global}
>   r7 ∈ [0, inf]
>   a7 ∈ {borrowed, global}
> mode rels
>   (a5,a4) ∉ {(borrowed,global)}
>   r4-r5 <= 0
>   r1-r4 ∈ [0, inf]

let shared = ((unit, unit) : (unit *[unique] unit)) in fork (let shared2 = shared in shared2)
> error: type mismatch between (unit * unit) and unit

let shared = ref unit in let _ = shared := unit in shared
> (ref[c=uncontended] unit)

let shared = ref unit in fork (let alias = shared in alias := unit)
> error: mode solver detected contention inconsistency

let shared = left(unit) in let alias = shared in match alias with left(x) => x | right(y) => unit
> unit

let shared = (unit, unit) in let! (a,b) = shared in a
> unit

let shared = ((unit, unit) : (unit *[unique] unit)) in let! (a,b) = shared in a
> unit

let f = fun x => fork x in f unit
> unit

let f = fun x => fork (x unit) in f (fun _ => unit)
> unit

let u = region (ref unit) in u
> (ref[c=c1] unit)
> mode vars
>   c1 ∈ {contended, shared, uncontended}

let r = region (ref unit) in fork (let x = !r in x)
> error: mode solver detected contention inconsistency

let f = fun x => (x, x) in f (ref unit)
> ((ref[c=c2] unit) *[u=u1 a=a1 r=r1] (ref[c=c1] unit))
> mode vars
>   c1 ∈ {contended, shared, uncontended}
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
>   c2 ∈ {contended, shared, uncontended}

let refpair = ref (unit, unit) in let x = !refpair in let! (a,b) = x in a
> error: mode solver detected uniqueness inconsistency

let refsum = ref left(unit) in region (let y = $right(unit) in refsum := y)
> unit

let f = (fun x => x) : unit ->[portable] unit in (f, f)
> ((unit ->[a=a1 r=r1 l=l1 p=p1] unit) *[u=u1 a=a2 r=r2] (unit ->[a=a1 r=r1 l=l1 p=p1] unit))
> mode vars
>   p1 ∈ {nonportable, portable}
>   l1 ∈ {many, never, once}
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   r2 ∈ [0, inf]
>   a2 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
> mode rels
>   r1-r2 ∈ [0, inf]

let f = (fun x => x) : unit ->[nonportable] unit in (f : unit ->[portable] unit)
> error: mode solver detected portability inconsistency

let f = (fun x => x) : unit ->[portable] unit in (f : unit ->[nonportable] unit)
> (unit ->[a=global r=r1 l=many p=nonportable] unit)
> mode vars
>   r1 ∈ [0, inf]

let shared = ref unit in let mk = fun _ => shared in (mk unit, mk unit)
> ((ref[c=c2] unit) *[u=u1 a=a1 r=r1] (ref[c=c1] unit))
> mode vars
>   c1 ∈ {contended, shared, uncontended}
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
>   c2 ∈ {contended, shared, uncontended}

let shared = ref unit in let mk = fun _ => !shared in fork (mk unit)
> error: mode solver detected portability inconsistency

let shared = ref unit in let mk = fun _ => shared in fork ((mk unit) := unit)
> error: mode solver detected contention inconsistency

let alias = ref unit in let pair = (alias, alias) in let (a,b) = pair in a := unit
> unit

let alias = ((unit, unit) : (unit *[unique] unit)) in let (a,b) = alias in (a,b)
> (unit *[u=u1 a=a1 r=r1] unit)
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}

let alias = ((unit, unit) : (unit *[unique global] unit)) in fork (let (a,b) = alias in a)
> unit

let alias = ((unit, unit) : (unit *[aliased global] unit)) in fork (let (a,b) = alias in a)
> unit

let alias = ((unit, unit) : (unit *[aliased] unit)) in fork (let (a,b) = alias in a)
> unit

let shared = ((unit, unit) : (unit *[aliased global] unit)) in let alias = shared in (shared, alias)
> ((unit *[u=aliased a=a1 r=r1] unit) *[u=u1 a=a2 r=r2] (unit *[u=aliased a=a1 r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   r2 ∈ [0, inf]
>   a2 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
> mode rels
>   r1-r2 ∈ [0, inf]

let shared = ((unit, unit) : (unit *[aliased global] unit)) in match left(shared) with left(x) => x | right(y) => shared
> (unit *[u=aliased a=a1 r=r1] unit)
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
