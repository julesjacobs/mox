unit
> unit

[]
> (list[u=u1 a=a1 r=r1] 'a)
> where
>   'a in {u=u2; c=c1; l=l1; p=p1; a=a2; r=r2}
> mode vars
>   r1 ∈ [r0, rinf]
>   a1 ∈ {borrowed, global, local, regional}
>   u1 ∈ {aliased, unique}
>   r2 ∈ [r0, rinf]
>   a2 ∈ {borrowed, global, local, regional}
>   p1 ∈ {nonportable, portable}
>   l1 ∈ {many, never, once}
>   c1 ∈ {contended, shared, uncontended}
>   u2 ∈ {aliased, unique}
> mode rels
>   (u2,u1) ∉ {(unique,aliased)}
>   (a2,a1) ∈ {(global,global), (global,regional), (global,local), (regional,regional), (regional,local), (local,local), (borrowed,borrowed)}

[unit]
> (list[u=u1 a=a1 r=r1] unit)
> mode vars
>   r1 ∈ [r0, rinf]
>   a1 ∈ {borrowed, global, local, regional}
>   u1 ∈ {aliased, unique}

unit :: []
> (list[u=u1 a=a1 r=r1] unit)
> mode vars
>   r1 ∈ [r0, rinf]
>   a1 ∈ {borrowed, global, local, regional}
>   u1 ∈ {aliased, unique}

match [unit] with [] => unit | x :: xs => x
> unit

1
> int

1 + 2
> int

(3 - 4) * 5
> int

-(1 + 2)
> int

let x = 1 in x + x
> int

let x = unit in x
> unit

((fun x => x) : (unit -> unit)) unit
> unit

(rec f x => x) unit
> unit

true
> bool

false
> bool

if true then unit else unit
> unit

if 1 < 2 then 1 else 2
> int

true and false
> bool

true or false
> bool

not false
> bool

1 == 2
> bool

1 < 2
> bool

1 >= 0
> bool

let pair = (unit, unit) in
let (x, y) = pair in x
> unit

((fun p => let (x, y) = p in y) : (unit * unit -> unit)) (unit, unit)
> unit

((fun x => absurd x) : (empty -> unit))
> (empty ->[a=global r=r1 l=many p=nonportable] unit)
> mode vars
>   r1 ∈ [r0, rinf]

(left(unit) : (unit + empty))
> (unit +[u=aliased a=global r=r1] empty)
> mode vars
>   r1 ∈ [r0, rinf]

(right(unit) : (empty + unit))
> (empty +[u=aliased a=global r=r1] unit)
> mode vars
>   r1 ∈ [r0, rinf]

(rec f x => f x + f x)
> ('a ->[a=a1 r=r1 l=many p=p1] int)
> where
>   'c <= 'b
>   'b <= 'd
>   'e <= 'd
>   'd <= 'a
>   'c <= 'e
>   'a <=[l=many] 'c
> mode vars
>   p1 ∈ {nonportable, portable}
>   r1 ∈ [r0, rinf]
>   a1 ∈ {borrowed, global, local, regional}

(rec f x => (x,x))
> ('c ->[a=a2 r=r2 l=many p=p1] ('b *[u=u1 a=a1 r=r1] 'a))
> where
>   'd <= 'a
>   'a in {u=u2; c=c1; l=l1; p=p2; a=a3; r=r3}
>   'd <= 'b
>   'b in {u=u2; c=c1; l=l1; p=p2; a=a3; r=r3}
>   'd in {u=u3; c=c2; l=l2; p=p3; a=a4; r=r4}
>   'd in {u=u3; c=c2; l=l2; p=p3; a=a4; r=r4}
>   'c <=[l=many] 'd
> mode vars
>   r1 ∈ [r0, rinf]
>   a1 ∈ {borrowed, global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {nonportable, portable}
>   r2 ∈ [r0, rinf]
>   a2 ∈ {borrowed, global, local, regional}
>   r3 ∈ [r0, rinf]
>   a3 ∈ {borrowed, global, local, regional}
>   p2 ∈ {nonportable, portable}
>   l1 ∈ {many, never, once}
>   c1 ∈ {contended, shared, uncontended}
>   u2 ∈ {aliased, unique}
>   r4 ∈ [r0, rinf]
>   a4 ∈ {borrowed, global, local, regional}
>   p3 ∈ {nonportable, portable}
>   l2 ∈ {many, never, once}
>   c2 ∈ {contended, shared, uncontended}
>   u3 ∈ {aliased, unique}
> mode rels
>   (u2,u1) ∉ {(unique,aliased)}
>   (a4,a1) ∉ {(regional,global), (local,global), (local,regional), (borrowed,global), (borrowed,regional), (borrowed,local)}
>   (a3,a1) ∈ {(global,global), (global,regional), (global,local), (regional,regional), (regional,local), (local,local), (borrowed,borrowed)}

rec f x => x
> ('b ->[a=a1 r=r1 l=many p=p1] 'a)
> where
>   'b <= 'a
> mode vars
>   p1 ∈ {nonportable, portable}
>   r1 ∈ [r0, rinf]
>   a1 ∈ {borrowed, global, local, regional}

rec f x => f x + x
> (int ->[a=a1 r=r1 l=many p=p1] int)
> mode vars
>   p1 ∈ {nonportable, portable}
>   r1 ∈ [r0, rinf]
>   a1 ∈ {borrowed, global, local, regional}

rec f x => (f 1 + 1, f)
> error: type mismatch between (int * (int -> int)) and int

rec f x => (f x + x, f)
> error: type mismatch between (int * (int -> int)) and int

