unit
> unit

[]
> (list[u=u1 a=a1] 'a)
> where
>   'a in {u=u2; c=c1; l=l1; p=p1; a=a2}
> mode vars
>   a1 ∈ {borrowed, global, local, regional}
>   u1 ∈ {aliased, unique}
>   a2 ∈ {borrowed, global, local, regional}
>   p1 ∈ {nonportable, portable}
>   l1 ∈ {many, never, once}
>   c1 ∈ {contended, shared, uncontended}
>   u2 ∈ {aliased, unique}
> mode rels
>   (u2,u1) ∉ {(unique,aliased)}
>   (a2,a1) ∈ {(global,global), (global,regional), (global,local), (regional,regional), (regional,local), (local,local), (borrowed,borrowed)}

[unit]
> (list[u=u1 a=a1] unit)
> mode vars
>   a1 ∈ {borrowed, global, local, regional}
>   u1 ∈ {aliased, unique}

unit :: []
> (list[u=u1 a=a1] unit)
> mode vars
>   a1 ∈ {borrowed, global, local, regional}
>   u1 ∈ {aliased, unique}

match [unit] with [] => unit | x :: xs => x
> unit

1
> int

1 + 2
> int

(3 - 4) * 5
> int

-(1 + 2)
> int

let x = 1 in x + x
> int

let x = unit in x
> unit

((fun x => x) : (unit -> unit)) unit
> unit

(rec f x => x) unit
> unit

let pair = (unit, unit) in
let (x, y) = pair in x
> unit

((fun p => let (x, y) = p in y) : (unit * unit -> unit)) (unit, unit)
> unit

((fun x => absurd x) : (empty -> unit))
> (empty ->[a=global l=many p=nonportable] unit)

(left(unit) : (unit + empty))
> (unit +[u=aliased a=global] empty)

(right(unit) : (empty + unit))
> (empty +[u=aliased a=global] unit)

(rec f x => f x + f x)
> ('a ->[a=a1 l=many p=p1] int)
> where
>   'a alias 'b
> mode vars
>   p1 ∈ {nonportable, portable}
>   a1 ∈ {borrowed, global, local, regional}
