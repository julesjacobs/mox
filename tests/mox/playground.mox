unit
> unit

fun x => x
> ('a ->[a=a1 l=l1 p=p1] 'a)
> mode vars
>   p1 ∈ {nonportable, portable}
>   l1 ∈ {many, never, once}
>   a1 ∈ {borrowed, global, local, regional}

(fun x => x) : (unit -> unit)
> (unit ->[a=global l=many p=nonportable] unit)

(fun x => (fun y => x))
> ('c ->[a=a2 l=l2 p=p2] ('b ->[a=a1 l=l1 p=p1] 'a))
> where
>   lock 'c -> 'a with a=a1 l=l1 p=p1
> mode vars
>   p1 ∈ {nonportable, portable}
>   l1 ∈ {many, never, once}
>   a1 ∈ {borrowed, global, local, regional}
>   p2 ∈ {nonportable, portable}
>   l2 ∈ {many, never, once}
>   a2 ∈ {borrowed, global, local, regional}

(fun x => (fun y => y))
> ('b ->[a=a2 l=l2 p=p2] ('a ->[a=a1 l=l1 p=p1] 'a))
> mode vars
>   p1 ∈ {nonportable, portable}
>   l1 ∈ {many, never, once}
>   a1 ∈ {borrowed, global, local, regional}
>   p2 ∈ {nonportable, portable}
>   l2 ∈ {many, never, once}
>   a2 ∈ {borrowed, global, local, regional}

(unit, unit) : (unit *[local unique] unit)
> (unit *[u=unique a=local] unit)

(fun p =>
let f = (fun x => x p) in
(f, f))
> ('d ->[a=a4 l=l3 p=p3] ((('c ->[a=a2 l=l2 p=p2] 'b) ->[a=a1 l=l1 p=p1] 'a) *[u=u1 a=a3] (('c ->[a=a2 l=l2 p=p2] 'b) ->[a=a1 l=l1 p=p1] 'a)))
> where
>   lock 'd -> 'e with a=a5 l=many p=p4
>   'f <= 'c
>   'b <= 'g
>   'h <= 'a
> mode vars
>   p1 ∈ {nonportable, portable}
>   l1 ∈ {many, never, once}
>   a1 ∈ {borrowed, global, local, regional}
>   p2 ∈ {nonportable, portable}
>   l2 ∈ {many, never, once}
>   a2 ∈ {borrowed, global, local, regional}
>   a3 ∈ {borrowed, global, local, regional}
>   u1 ∈ {aliased, unique}
>   p3 ∈ {nonportable, portable}
>   l3 ∈ {many, never, once}
>   a4 ∈ {borrowed, global, local, regional}
>   p4 ∈ {nonportable, portable}
>   a5 ∈ {borrowed, global, local, regional}
> mode rels
>   (a5,a3) ∉ {(regional,global), (local,global), (local,regional), (borrowed,global), (borrowed,regional), (borrowed,local)}
>   (a5,a1) ∉ {(regional,global), (local,global), (local,regional), (borrowed,global), (borrowed,regional), (borrowed,local)}
>   (p4,p1) ∉ {(nonportable,portable)}

let x = (unit, unit) in
let y = (x,x) in
let! (a,b) = y in a
> (unit *[u=aliased a=a1] unit)
> mode vars
>   a1 ∈ {borrowed, global, local, regional}

let x = (unit, unit) in
let y = (x,x) in
let! (a,b) = y in 
let! (c,d) = a in c
> error: mode solver detected uniqueness inconsistency
