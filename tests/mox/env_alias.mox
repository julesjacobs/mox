(* application: shared variable used in both function and argument *)
let shared = ((unit, unit) : (unit *[unique global] unit)) in
((fun f => f shared) : ((unit *[unique global] unit) -> unit) -> unit)
  ((fun g => g shared) : ((unit *[unique global] unit) -> unit))
> error: mode solver detected uniqueness inconsistency

(* application: non-shared variables used in both functions *)
let non_shared1 = ((unit, unit) : (unit *[unique] unit)) in
let non_shared2 = ((unit, unit) : (unit *[unique] unit)) in
(((fun f => f non_shared1) : ((unit *[unique] unit) -> unit) ->[once] unit),
 ((fun g => g non_shared2) : ((unit *[unique] unit) -> unit) ->[once] unit))
> ((((unit *[u=unique a=global r=r7] unit) ->[a=global r=r6 l=many p=nonportable] unit) ->[a=global r=r5 l=once p=nonportable] unit) *[u=u1 a=a1 r=r4] (((unit *[u=unique a=global r=r3] unit) ->[a=global r=r2 l=many p=nonportable] unit) ->[a=global r=r1 l=once p=nonportable] unit))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]
>   r3 ∈ [0, inf]
>   r4 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
>   r5 ∈ [0, inf]
>   r6 ∈ [0, inf]
>   r7 ∈ [0, inf]
> mode rels
>   r4-r5 <= 0
>   r1-r4 ∈ [0, inf]

(* application: non-shared variables used in both functions, but one is many *)
let non_shared1 = ((unit, unit) : (unit *[unique] unit)) in
let non_shared2 = ((unit, unit) : (unit *[unique] unit)) in
(((fun f => f non_shared1) : ((unit *[unique] unit) ->[once] unit) ->[many] unit),
 ((fun g => g non_shared2) : ((unit *[unique] unit) ->[once] unit) ->[once] unit))
> error: mode solver detected uniqueness inconsistency

(* application: shared variable used in both function and argument *)
let shared = ((unit, unit) : (unit *[unique] unit)) in
(((fun f => f shared) : ((unit *[unique] unit) ->[once] unit) ->[once] unit),
 ((fun g => g shared) : ((unit *[unique] unit) ->[once] unit) ->[once] unit))
> error: mode solver detected uniqueness inconsistency

(* pair: shared variable appears in both components *)
let shared = ((unit, unit) : (unit *[unique global] unit)) in
(shared, shared) : (unit *[global] unit) *[global] (unit *[global] unit)
> ((unit *[u=aliased a=global r=r3] unit) *[u=aliased a=global r=r2] (unit *[u=aliased a=global r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]
>   r3 ∈ [0, inf]
> mode rels
>   r2-r3 <= 0
>   r1-r2 ∈ [0, inf]

(* pair: shared variable appears in both components *)
let shared = ((unit, unit) : (unit *[unique] unit)) in
(shared, shared) : (unit *[aliased] unit) *[unique] (unit *[aliased] unit)
> ((unit *[u=aliased a=global r=r3] unit) *[u=unique a=global r=r2] (unit *[u=aliased a=global r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]
>   r3 ∈ [0, inf]
> mode rels
>   r2-r3 <= 0
>   r1-r2 ∈ [0, inf]

(* let-binding: shared variable used in initializer and body *)
let shared = ((unit, unit) : (unit *[global] unit)) in
let alias = shared in
(shared, alias)
> ((unit *[u=aliased a=a1 r=r1] unit) *[u=u1 a=a2 r=r2] (unit *[u=aliased a=a1 r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   r2 ∈ [0, inf]
>   a2 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
> mode rels
>   r1-r2 ∈ [0, inf]

(* let-pair: shared variable used alongside destructured pair *)
let shared = ((unit, unit) : (unit *[unique global] unit)) in
let pair = (shared, shared) in
let (x, y) = pair in
(x, y)
> ((unit *[u=aliased a=a3 r=r3] unit) *[u=u1 a=a2 r=r2] (unit *[u=aliased a=a1 r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   r2 ∈ [0, inf]
>   a2 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
>   r3 ∈ [0, inf]
>   a3 ∈ {borrowed, global}
> mode rels
>   (a3,a2) ∉ {(borrowed,global)}
>   r2-r3 <= 0
>   r1-r2 ∈ [0, inf]

(* match: shared variable used in both branches *)
let shared = ((unit, unit) : (unit *[unique global] unit)) in
match left(shared) with left(x) => x | right(y) => shared
> (unit *[u=aliased a=a1 r=r1] unit)
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}

(* pair with aliased shared value *)
let shared = ((unit, unit) : (unit *[aliased] unit)) in
(shared, shared)
> ((unit *[u=aliased a=a1 r=r1] unit) *[u=u1 a=a2 r=r2] (unit *[u=aliased a=a1 r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   r2 ∈ [0, inf]
>   a2 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
> mode rels
>   r1-r2 ∈ [0, inf]

(* let-binding success with aliasable shared value *)
let shared = ((unit, unit) : (unit *[aliased] unit)) in
let alias = shared in
(shared, alias)
> ((unit *[u=aliased a=a1 r=r1] unit) *[u=u1 a=a2 r=r2] (unit *[u=aliased a=a1 r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   r2 ∈ [0, inf]
>   a2 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
> mode rels
>   r1-r2 ∈ [0, inf]

(* let-pair success with aliasable shared value *)
let shared = ((unit, unit) : (unit *[aliased] unit)) in
let pair = (shared, shared) in
let (x, y) = pair in
(x, y)
> ((unit *[u=aliased a=a3 r=r3] unit) *[u=u1 a=a2 r=r2] (unit *[u=aliased a=a1 r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   r2 ∈ [0, inf]
>   a2 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}
>   r3 ∈ [0, inf]
>   a3 ∈ {borrowed, global}
> mode rels
>   (a3,a2) ∉ {(borrowed,global)}
>   r2-r3 <= 0
>   r1-r2 ∈ [0, inf]

(* match with aliasable shared value still fails: need better inference *)
let shared = ((unit, unit) : (unit *[aliased global] unit)) in
match left(shared) with left(x) => x | right(y) => shared
> (unit *[u=aliased a=a1 r=r1] unit)
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
