(* Stack allocated pair cannot escape from region *)
region $(1,2)
> error: mode solver detected regionality inconsistency (1 <= 0)

(* Normal pairs can *)
region (1,2)
> (int *[u=u1 a=global r=r1] int)
> mode vars
>   r1 ∈ [0, inf]
>   u1 ∈ {aliased, unique}

(* Original region of value is tracked *)
let x = $(1,2) in region x
> (int *[u=u1 a=global r=0] int)
> mode vars
>   u1 ∈ {aliased, unique}

(* Can allocate in upper region with $$, $$$, etc. *)
region
  let x = $$(1,2) in
  let cond = true in
  region 
    if cond then x else $$$(2,3)
> (int *[u=u1 a=global r=0] int)
> mode vars
>   u1 ∈ {aliased, unique}

(* Automatic modalities: can store global data in stack allocated data *)
let x = (1,2) in
region
  let y = $(x,x) in
  let (a,b) = y in a
> (int *[u=aliased a=global r=r1] int)
> mode vars
>   r1 ∈ [0, inf]

(* The reverse is not allowed *)
region
  let x = $(1,2) in
  let y = (x,x) in
  let (a,b) = y in a
> error: mode solver detected regionality inconsistency (1 <= 0)

(* Complex example with fold where we do the recursive call under a region *)
(* No matter how deeply we allocate the cons, we cannot allow this as it can escape arbitrarily many regions. *)
let fold = fun f => fun z => rec go xs => match xs with [] => z | a :: as => region (f a (go as)) 
in fold (fun x => fun y => x $$$$$$$:: y) [] [1,2,3]
> error: mode solver detected regionality inconsistency (inf <= 6)

(* Interestingly, this type checks, because we only pass the pair up 1 region and then discard it. *)
let fold = fun f => fun z => rec go xs => match xs with [] => z | a :: as => region (f a (go as)) 
in fold (fun x => fun y => $$(1,2)) (2,3) [1,2,3]
> (int *[u=aliased a=a1 r=0] int)
> mode vars
>   a1 ∈ {borrowed, global}

(* Destructive pair matching is only allowed on unique pairs *)
let x = (1,2) in 
let! (a,b) = x in a
> int

(* Not allowed on aliased pairs *)
let x = (1,2) in
let y = (x,x) in
let! (a,b) = x in a
> error: mode solver detected uniqueness inconsistency

(* Borrowing *)
let x = (1,2) in
let fst = (fun p => let (x,y) = p in x) in
borrow y = x for z = fst y in let! (a,b) = y in (z,b)
> (int *[u=u1 a=a1 r=r1] int)
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}

(* In the borrow, data becomes aliased *)
let x = (1,2) in
let fst = (fun p => let! (x,y) = p in x) in
borrow y = x for z = fst y in let! (a,b) = y in (z,b)
> error: mode solver detected uniqueness inconsistency

(* In the borrow, data becomes borrowed *)
let x = (1,2) in
let r = ref (3,4) in
let fst = (fun p => let _ = (r := p) in let (x,y) = p in x) in
borrow y = x for z = fst y in let! (a,b) = y in (z,b)
> error: mode solver detected areality inconsistency

(* We can store aliased data in unique data *)
let x = (1,2) in
let y = (x,x) in
let! (a,b) = y in a
> (int *[u=aliased a=a1 r=r1] int)
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}

(* Concurrency: catching data races *)
let r = ref 3 in
let g = fun x => r := !r + x in
let _ = fork (g 1) in g 2
> error: mode solver detected portability inconsistency
