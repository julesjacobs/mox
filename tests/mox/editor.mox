(* Stack allocated pair cannot escape from region *)
region $(1,2)
> error: mode solver detected regionality inconsistency (1 <= 0)

(* Normal pairs can *)
region (1,2)
> (int *[u=u1 a=global r=r1] int)
> mode vars
>   r1 ∈ [0, inf]
>   u1 ∈ {aliased, unique}

(* Original region of value is tracked *)
let x = $(1,2) in region x
> (int *[u=u1 a=global r=0] int)
> mode vars
>   u1 ∈ {aliased, unique}

(* Can allocate in upper region with $$, $$$, etc. *)
region
  let x = $$(1,2) in
  let cond = true in
  region 
    if cond then x else $$$(2,3)
> (int *[u=u1 a=global r=0] int)
> mode vars
>   u1 ∈ {aliased, unique}

(* Automatic modalities: can store global data in stack allocated data *)
let x = (1,2) in
region
  let y = $(x,x) in
  let (a,b) = y in a
> (int *[u=aliased a=global r=r1] int)
> mode vars
>   r1 ∈ [0, inf]

(* The reverse is not allowed *)
region
  let x = $(1,2) in
  let y = (x,x) in
  let (a,b) = y in a
> error: mode solver detected regionality inconsistency (1 <= 0)

(* Complex example with fold where we do the recursive call under a region *)
(* No matter how deeply we allocate the cons, we cannot allow this as it can escape arbitrarily many regions. *)
let fold = fun f => fun z => rec go xs => match xs with [] => z | a :: as => region (f a (go as)) 
in fold (fun x => fun y => x $$$$$$$:: y) [] [1,2,3]
> error: mode solver detected regionality inconsistency (inf <= 6)

(* Interestingly, this type checks, because we only pass the pair up 1 region and then discard it. *)
let fold = fun f => fun z => rec go xs => match xs with [] => z | a :: as => region (f a (go as)) 
in fold (fun x => fun y => $$(1,2)) (2,3) [1,2,3]
> (int *[u=aliased a=a1 r=0] int)
> mode vars
>   a1 ∈ {borrowed, global}

(* Concurrency: catching data races *)
let r = ref 3 in
let g = fun x => r := !r + x in
let _ = fork (g 1) in g 2
> error: mode solver detected portability inconsistency

(* Destructive pair matching is only allowed on unique pairs *)
let x = (1,2) in 
let! (a,b) = x in a
> int

(* Not allowed on aliased pairs *)
let x = (1,2) in
let y = (x,x) in
let! (a,b) = x in a
> error: mode solver detected uniqueness inconsistency

(* Borrowing *)
let x = (1,2) in
let fst = (fun p => let (x,y) = p in x) in
borrow y = x for z = fst y in let! (a,b) = y in (z,b)
> (int *[u=u1 a=a1 r=r1] int)
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u1 ∈ {aliased, unique}

(* In the borrow, data becomes aliased *)
let x = (1,2) in
let fst = (fun p => let! (x,y) = p in x) in
borrow y = x for z = fst y in let! (a,b) = y in (z,b)
> error: mode solver detected uniqueness inconsistency

(* In the borrow, data becomes borrowed *)
let x = (1,2) in
let r = ref (3,4) in
let fst = (fun p => let _ = (r := p) in let (x,y) = p in x) in
borrow y = x for z = fst y in let! (a,b) = y in (z,b)
> error: mode solver detected uniqueness inconsistency

(* We can store aliased data in unique data *)
let x = (1,2) in
let y = (x,x) in
let! (a,b) = y in a
> (int *[u=aliased a=a1 r=r1] int)
> mode vars
>   r1 ∈ [0, inf]
>   a1 ∈ {borrowed, global}

(* Partial borrowing *)
let map = fun f => rec go xs => match xs with [] => [] | x :: xs => f x :: go xs in
let fst = fun p => let (a,b) = p in a in
let lst = [([1],[2]),([3],[4]),([5],[6])] in
borrow xs = lst for ys = map fst xs in
(xs, ys)
> ((list[u=u5 a=a4 r=r7] ((list[u=aliased a=global r=r6] int) *[u=u4 a=a3 r=r5] (list[u=u3 a=a2 r=r4] int))) *[u=u2 a=a1 r=r3] (list[u=u1 a=global r=r2] (list[u=aliased a=global r=r1] int)))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]
>   u1 ∈ {aliased, unique}
>   r3 ∈ [0, inf]
>   a1 ∈ {borrowed, global}
>   u2 ∈ {aliased, unique}
>   r4 ∈ [0, inf]
>   a2 ∈ {borrowed, global}
>   u3 ∈ {aliased, unique}
>   r5 ∈ [0, inf]
>   a3 ∈ {borrowed, global}
>   u4 ∈ {aliased, unique}
>   r6 ∈ [0, inf]
>   r7 ∈ [0, inf]
>   a4 ∈ {borrowed, global}
>   u5 ∈ {aliased, unique}
> mode rels
>   (u5,u2) ∉ {(unique,aliased)}
>   (u4,u2) ∉ {(unique,aliased)}
>   (u3,u2) ∉ {(unique,aliased)}
>   (a4,a1) ∉ {(borrowed,global)}
>   (a3,a1) ∉ {(borrowed,global)}
>   (a2,a1) ∉ {(borrowed,global)}
>   r6-r7 ∈ [0, inf]
>   r5-r7 ∈ [0, inf]
>   r4-r7 ∈ [0, inf]
>   r3-r7 <= 0
>   r5-r6 <= 0
>   r3-r6 <= 0
>   r2-r6 <= 0
>   r1-r6 <= 0
>   r4-r5 ∈ [0, inf]
>   r3-r5 <= 0
>   r3-r4 <= 0
>   r2-r3 ∈ [0, inf]
>   r1-r3 ∈ [0, inf]
>   r1-r2 ∈ [0, inf]
