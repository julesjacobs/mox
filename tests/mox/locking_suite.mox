(* many closure fails when capturing unique pair directly *)
let unique_pair = ((unit, unit) : (unit *[unique global] unit)) in
((fun _ => unique_pair) : (unit ->[global many] (unit *[unique global] unit)))
> error: mode solver detected uniqueness inconsistency

(* once closure succeeds when capturing unique pair directly *)
let unique_pair = ((unit, unit) : (unit *[unique global] unit)) in
((fun _ => unique_pair) : (unit ->[global once] (unit *[unique global] unit)))
> (unit ->[a=global r=r2 l=once p=nonportable] (unit *[u=unique a=global r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]

(* once closure succeeds after rebinding unique pair *)
let unique_pair1 = ((unit, unit) : (unit *[unique global] unit)) in
let unique_pair2 = unique_pair1 in
((fun _ => unique_pair2) : (unit ->[global once] (unit *[unique global] unit)))
> (unit ->[a=global r=r2 l=once p=nonportable] (unit *[u=unique a=global r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]

(* many closure fails after alias binding to unique pair *)
let base = ((unit, unit) : (unit *[unique global] unit)) in
let alias = base in
((fun _ => alias) : (unit ->[global many] (unit *[unique global] unit)))
> error: mode solver detected uniqueness inconsistency

(* many closure succeeds with aliased storage after alias binding *)
let base = ((unit, unit) : (unit *[unique global] unit)) in
let alias = base in
((fun _ => alias) : (unit ->[global many] (unit *[global] unit)))
> (unit ->[a=global r=r2 l=many p=nonportable] (unit *[u=aliased a=global r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]

(* many closure fails on nested unique pair *)
let nested = ((unit, (unit, unit)) : (unit *[unique global] (unit *[unique global] unit))) in
((fun _ => nested)
 : (unit ->[global many] (unit *[unique global] (unit *[unique global] unit))))
> error: mode solver detected uniqueness inconsistency

(* many closure succeeds on nested pair with aliased storage *)
let nested =
  ((unit, (unit, unit)) : (unit *[unique global] (unit *[unique global] unit)))
in
((fun _ => nested)
 : (unit ->[global many] (unit *[global] (unit *[global] unit))))
> (unit ->[a=global r=r3 l=many p=nonportable] (unit *[u=aliased a=global r=r2] (unit *[u=aliased a=global r=r1] unit)))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]
>   r3 ∈ [0, inf]
> mode rels
>   r1-r2 ∈ [0, inf]

(* many closure fails on unique sum *)
let unique_sum = (left(unit) : (unit +[unique global] unit)) in
((fun _ => unique_sum) : (unit ->[global many] (unit +[unique global] unit)))
> error: mode solver detected uniqueness inconsistency

(* many closure succeeds on aliased sum *)
let unique_sum = (left(unit) : (unit +[unique global] unit)) in
((fun _ => unique_sum) : (unit ->[global many] (unit +[global] unit)))
> (unit ->[a=global r=r2 l=many p=nonportable] (unit +[u=aliased a=global r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]

(* many closure fails on nested unique sum *)
let nested_sum =
  (right(left(unit)) : (unit +[unique global] (unit +[unique global] unit)))
in
((fun _ => nested_sum)
 : (unit ->[global many] (unit +[unique global] (unit +[unique global] unit))))
> error: mode solver detected uniqueness inconsistency

(* many closure succeeds on nested sum with aliased storage *)
let nested_sum =
  (right(left(unit)) : (unit +[unique global] (unit +[unique global] unit)))
in
((fun _ => nested_sum)
 : (unit ->[global many] (unit +[global] (unit +[global] unit))))
> (unit ->[a=global r=r3 l=many p=nonportable] (unit +[u=aliased a=global r=r2] (unit +[u=aliased a=global r=r1] unit)))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]
>   r3 ∈ [0, inf]
> mode rels
>   r1-r2 ∈ [0, inf]

(* once closure fails on aliased function capture *)
let aliased_fun = ((fun x => x) : (unit ->[global many] unit)) in
((fun _ => aliased_fun) : (unit ->[global once] (unit ->[global many] unit)))
> (unit ->[a=global r=r2 l=once p=nonportable] (unit ->[a=global r=r1 l=many p=nonportable] unit))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]

(* many closure succeeds on once-qualified function capture *)
let linear_fun = ((fun x => x) : (unit ->[global once] unit)) in
((fun _ => linear_fun) : (unit ->[global many] (unit ->[global once] unit)))
> error: mode solver detected linearity inconsistency

(* once closure fails on portable function capture *)
let portable_fun = ((fun x => x) : (unit ->[global once portable] unit)) in
((fun _ => portable_fun)
 : (unit ->[global once] (unit ->[global once portable] unit)))
> (unit ->[a=global r=r2 l=once p=nonportable] (unit ->[a=global r=r1 l=once p=portable] unit))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]

(* once closure succeeds when requiring portable capability *)
let portable_fun = ((fun x => x) : (unit ->[global once portable] unit)) in
((fun _ => portable_fun)
 : (unit ->[global once portable] (unit ->[global once portable] unit)))
> (unit ->[a=global r=r2 l=once p=portable] (unit ->[a=global r=r1 l=once p=portable] unit))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]

(* once closure fails via pair.left path *)
let pair_left =
  (((fun x => x) : (unit ->[global many] unit)), unit)
  : ((unit ->[global many] unit) *[unique global] unit)
in
((fun _ => pair_left)
 : (unit ->[global once] ((unit ->[global many] unit) *[unique global] unit)))
> (unit ->[a=global r=r3 l=once p=nonportable] ((unit ->[a=global r=r2 l=many p=nonportable] unit) *[u=unique a=global r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]
>   r3 ∈ [0, inf]
> mode rels
>   r1-r2 <= 0

(* once closure fails via pair.right path *)
let pair_right =
  (unit,
   ((fun x => x) : (unit ->[global many] unit)))
  : (unit *[unique global] (unit ->[global many] unit))
in
((fun _ => pair_right)
 : (unit ->[global once] (unit *[unique global] (unit ->[global many] unit))))
> (unit ->[a=global r=r3 l=once p=nonportable] (unit *[u=unique a=global r=r2] (unit ->[a=global r=r1 l=many p=nonportable] unit)))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]
>   r3 ∈ [0, inf]
> mode rels
>   r1-r2 ∈ [0, inf]

(* once closure fails via sum.left path *)
let sum_left =
  (left(((fun x => x) : (unit ->[global many] unit))))
  : ((unit ->[global many] unit) +[unique global] unit)
in
((fun _ => sum_left)
 : (unit ->[global once] ((unit ->[global many] unit) +[unique global] unit)))
> (unit ->[a=global r=r3 l=once p=nonportable] ((unit ->[a=global r=r2 l=many p=nonportable] unit) +[u=unique a=global r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]
>   r3 ∈ [0, inf]
> mode rels
>   r1-r2 <= 0

(* once closure fails via sum.right path *)
let sum_right =
  (right(((fun x => x) : (unit ->[global many] unit))))
  : (unit +[unique global] (unit ->[global many] unit))
in
((fun _ => sum_right)
 : (unit ->[global once] (unit +[unique global] (unit ->[global many] unit))))
> (unit ->[a=global r=r3 l=once p=nonportable] (unit +[u=unique a=global r=r2] (unit ->[a=global r=r1 l=many p=nonportable] unit)))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]
>   r3 ∈ [0, inf]
> mode rels
>   r1-r2 ∈ [0, inf]

(* once closure fails via nested pair path chain *)
let nested_pair =
  ((unit,
    ((fun x => x) : (unit ->[global many] unit)))
   : (unit *[unique global] (unit ->[global many] unit)))
in
let bundle =
  (nested_pair, unit)
  : ((unit *[unique global] (unit ->[global many] unit)) *[unique global] unit)
in
((fun _ => bundle)
 : (unit
    ->[global once]
    ((unit *[unique global] (unit ->[global many] unit)) *[unique global] unit)))
> (unit ->[a=global r=r4 l=once p=nonportable] ((unit *[u=unique a=global r=r3] (unit ->[a=global r=r2 l=many p=nonportable] unit)) *[u=unique a=global r=r1] unit))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]
>   r3 ∈ [0, inf]
>   r4 ∈ [0, inf]
> mode rels
>   r2-r3 ∈ [0, inf]
>   r1-r3 <= 0
>   r1-r2 <= 0

(* once closure fails via nested sum path chain *)
let nested_sum_fn =
  (left(((fun x => x) : (unit ->[global many] unit))))
  : ((unit ->[global many] unit) +[unique global] unit)
in
let bundle =
  (right(nested_sum_fn))
  : (unit +[unique global] ((unit ->[global many] unit) +[unique global] unit))
in
((fun _ => bundle)
 : (unit
    ->[global once]
    (unit +[unique global] ((unit ->[global many] unit) +[unique global] unit))))
> (unit ->[a=global r=r4 l=once p=nonportable] (unit +[u=unique a=global r=r3] ((unit ->[a=global r=r2 l=many p=nonportable] unit) +[u=unique a=global r=r1] unit)))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]
>   r3 ∈ [0, inf]
>   r4 ∈ [0, inf]
> mode rels
>   r2-r3 ∈ [0, inf]
>   r1-r3 ∈ [0, inf]
>   r1-r2 <= 0

(* many closure succeeds on nested pair with once-qualified function *)
let nested_pair_once =
  ((unit,
    ((fun x => x) : (unit ->[global once] unit)))
   : (unit *[unique global] (unit ->[global once] unit)))
in
let bundle =
  (nested_pair_once, unit)
  : ((unit *[unique global] (unit ->[global once] unit)) *[unique global] unit)
in
((fun _ => bundle)
 : (unit
    ->[global many]
    ((unit *[global] (unit ->[global once] unit)) *[global] unit)))
> error: mode solver detected linearity inconsistency

(* many closure succeeds on nested sum with once-qualified function *)
let nested_sum_once =
  (left(((fun x => x) : (unit ->[global once] unit))))
  : ((unit ->[global once] unit) +[unique global] unit)
in
let bundle =
  (right(nested_sum_once))
  : (unit +[unique global] ((unit ->[global once] unit) +[unique global] unit))
in
((fun _ => bundle)
 : (unit
    ->[global many]
    (unit +[global] ((unit ->[global once] unit) +[global] unit))))
> error: mode solver detected linearity inconsistency

(* once closure fails when capturing a many-closure as a value *)
let unique_pair = ((unit, unit) : (unit *[unique global] unit)) in
let inner =
  ((fun _ => unique_pair) : (unit ->[global many] (unit *[global] unit)))
in
((fun _ => inner)
 : (unit ->[global once] (unit ->[global many] (unit *[global] unit))))
> (unit ->[a=global r=r3 l=once p=nonportable] (unit ->[a=global r=r2 l=many p=nonportable] (unit *[u=aliased a=global r=r1] unit)))
> mode vars
>   r1 ∈ [0, inf]
>   r2 ∈ [0, inf]
>   r3 ∈ [0, inf]

(* many closure succeeds when capturing a once-closure as a value *)
let unique_pair = ((unit, unit) : (unit *[unique global] unit)) in
let inner =
  ((fun _ => unique_pair) : (unit ->[global once] (unit *[unique global] unit)))
in
((fun _ => inner)
 : (unit ->[global many] (unit ->[global once] (unit *[unique global] unit))))
> error: mode solver detected linearity inconsistency
