(* many closure fails when capturing unique pair directly *)
let unique_pair = ((unit, unit) : (unit *[unique local] unit)) in
((fun _ => unique_pair) : (unit ->[local many] (unit *[unique local] unit)))
> (unit ->[a=a2 l=l1 p=p1] (unit *[u=u1 a=a1] unit))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}

(* once closure succeeds when capturing unique pair directly *)
let unique_pair = ((unit, unit) : (unit *[unique local] unit)) in
((fun _ => unique_pair) : (unit ->[local once] (unit *[unique local] unit)))
> (unit ->[a=a2 l=l1 p=p1] (unit *[u=u1 a=a1] unit))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}

(* once closure succeeds after rebinding unique pair *)
let unique_pair1 = ((unit, unit) : (unit *[unique local] unit)) in
let unique_pair2 = unique_pair1 in
((fun _ => unique_pair2) : (unit ->[local once] (unit *[unique local] unit)))
> (unit ->[a=a2 l=l1 p=p1] (unit *[u=u1 a=a1] unit))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}

(* many closure fails after alias binding to unique pair *)
let base = ((unit, unit) : (unit *[unique local] unit)) in
let alias = base in
((fun _ => alias) : (unit ->[local many] (unit *[unique local] unit)))
> (unit ->[a=a2 l=l1 p=p1] (unit *[u=u1 a=a1] unit))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}

(* many closure succeeds with aliased storage after alias binding *)
let base = ((unit, unit) : (unit *[unique local] unit)) in
let alias = base in
((fun _ => alias) : (unit ->[local many] (unit *[local] unit)))
> (unit ->[a=a2 l=l1 p=p1] (unit *[u=u1 a=a1] unit))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}

(* many closure fails on nested unique pair *)
let nested = ((unit, (unit, unit)) : (unit *[unique local] (unit *[unique local] unit))) in
((fun _ => nested)
 : (unit ->[local many] (unit *[unique local] (unit *[unique local] unit))))
> (unit ->[a=a3 l=l1 p=p1] (unit *[u=u2 a=a2] (unit *[u=u1 a=a1] unit)))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   a2 ∈ {global, local, regional}
>   u2 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a3 ∈ {global, local, regional}

(* many closure succeeds on nested pair with aliased storage *)
let nested =
  ((unit, (unit, unit)) : (unit *[unique local] (unit *[unique local] unit)))
in
((fun _ => nested)
 : (unit ->[local many] (unit *[local] (unit *[local] unit))))
> (unit ->[a=a3 l=l1 p=p1] (unit *[u=u2 a=a2] (unit *[u=u1 a=a1] unit)))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   a2 ∈ {global, local, regional}
>   u2 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a3 ∈ {global, local, regional}

(* many closure fails on unique sum *)
let unique_sum = (left(unit) : (unit +[unique local] unit)) in
((fun _ => unique_sum) : (unit ->[local many] (unit +[unique local] unit)))
> (unit ->[a=a2 l=l1 p=p1] (unit +[u=u1 a=a1] unit))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}

(* many closure succeeds on aliased sum *)
let unique_sum = (left(unit) : (unit +[unique local] unit)) in
((fun _ => unique_sum) : (unit ->[local many] (unit +[local] unit)))
> (unit ->[a=a2 l=l1 p=p1] (unit +[u=u1 a=a1] unit))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}

(* many closure fails on nested unique sum *)
let nested_sum =
  (right(left(unit)) : (unit +[unique local] (unit +[unique local] unit)))
in
((fun _ => nested_sum)
 : (unit ->[local many] (unit +[unique local] (unit +[unique local] unit))))
> (unit ->[a=a3 l=l1 p=p1] (unit +[u=u2 a=a2] (unit +[u=u1 a=a1] unit)))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   a2 ∈ {global, local, regional}
>   u2 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a3 ∈ {global, local, regional}

(* many closure succeeds on nested sum with aliased storage *)
let nested_sum =
  (right(left(unit)) : (unit +[unique local] (unit +[unique local] unit)))
in
((fun _ => nested_sum)
 : (unit ->[local many] (unit +[local] (unit +[local] unit))))
> (unit ->[a=a3 l=l1 p=p1] (unit +[u=u2 a=a2] (unit +[u=u1 a=a1] unit)))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   a2 ∈ {global, local, regional}
>   u2 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a3 ∈ {global, local, regional}

(* once closure fails on aliased function capture *)
let aliased_fun = ((fun x => x) : (unit ->[local many] unit)) in
((fun _ => aliased_fun) : (unit ->[local once] (unit ->[local many] unit)))
> (unit ->[a=a2 l=l2 p=p2] (unit ->[a=a1 l=l1 p=p1] unit))
> mode vars
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a1 ∈ {global, local, regional}
>   p2 ∈ {non-portable, portable}
>   l2 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}
> mode rels
>   (a2,a1) ∉ {(regional,global), (local,global), (local,regional)}
>   (l2,l1) ∉ {(once,many), (never,many), (never,once)}
>   (p2,p1) ∉ {(non-portable,portable)}

(* many closure succeeds on once-qualified function capture *)
let linear_fun = ((fun x => x) : (unit ->[local once] unit)) in
((fun _ => linear_fun) : (unit ->[local many] (unit ->[local once] unit)))
> (unit ->[a=a2 l=l2 p=p2] (unit ->[a=a1 l=l1 p=p1] unit))
> mode vars
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a1 ∈ {global, local, regional}
>   p2 ∈ {non-portable, portable}
>   l2 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}
> mode rels
>   (a2,a1) ∉ {(regional,global), (local,global), (local,regional)}
>   (l2,l1) ∉ {(once,many), (never,many), (never,once)}
>   (p2,p1) ∉ {(non-portable,portable)}

(* once closure fails on portable function capture *)
let portable_fun = ((fun x => x) : (unit ->[local once portable] unit)) in
((fun _ => portable_fun)
 : (unit ->[local once] (unit ->[local once portable] unit)))
> (unit ->[a=a2 l=l2 p=p2] (unit ->[a=a1 l=l1 p=p1] unit))
> mode vars
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a1 ∈ {global, local, regional}
>   p2 ∈ {non-portable, portable}
>   l2 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}
> mode rels
>   (a2,a1) ∉ {(regional,global), (local,global), (local,regional)}
>   (l2,l1) ∉ {(once,many), (never,many), (never,once)}
>   (p2,p1) ∉ {(non-portable,portable)}

(* once closure succeeds when requiring portable capability *)
let portable_fun = ((fun x => x) : (unit ->[local once portable] unit)) in
((fun _ => portable_fun)
 : (unit ->[local once portable] (unit ->[local once portable] unit)))
> (unit ->[a=a2 l=l2 p=p2] (unit ->[a=a1 l=l1 p=p1] unit))
> mode vars
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a1 ∈ {global, local, regional}
>   p2 ∈ {non-portable, portable}
>   l2 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}
> mode rels
>   (a2,a1) ∉ {(regional,global), (local,global), (local,regional)}
>   (l2,l1) ∉ {(once,many), (never,many), (never,once)}
>   (p2,p1) ∉ {(non-portable,portable)}

(* once closure fails via pair.left path *)
let pair_left =
  (((fun x => x) : (unit ->[local many] unit)), unit)
  : ((unit ->[local many] unit) *[unique local] unit)
in
((fun _ => pair_left)
 : (unit ->[local once] ((unit ->[local many] unit) *[unique local] unit)))
> (unit ->[a=a3 l=l2 p=p2] ((unit ->[a=a2 l=l1 p=p1] unit) *[u=u1 a=a1] unit))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}
>   p2 ∈ {non-portable, portable}
>   l2 ∈ {many, never, once}
>   a3 ∈ {global, local, regional}
> mode rels
>   (a3,a2) ∉ {(regional,global), (local,global), (local,regional)}
>   (l2,l1) ∉ {(once,many), (never,many), (never,once)}
>   (p2,p1) ∉ {(non-portable,portable)}

(* once closure fails via pair.right path *)
let pair_right =
  (unit,
   ((fun x => x) : (unit ->[local many] unit)))
  : (unit *[unique local] (unit ->[local many] unit))
in
((fun _ => pair_right)
 : (unit ->[local once] (unit *[unique local] (unit ->[local many] unit))))
> (unit ->[a=a3 l=l2 p=p2] (unit *[u=u1 a=a2] (unit ->[a=a1 l=l1 p=p1] unit)))
> mode vars
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a1 ∈ {global, local, regional}
>   a2 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p2 ∈ {non-portable, portable}
>   l2 ∈ {many, never, once}
>   a3 ∈ {global, local, regional}
> mode rels
>   (a3,a1) ∉ {(regional,global), (local,global), (local,regional)}
>   (l2,l1) ∉ {(once,many), (never,many), (never,once)}
>   (p2,p1) ∉ {(non-portable,portable)}

(* once closure fails via sum.left path *)
let sum_left =
  (left(((fun x => x) : (unit ->[local many] unit))))
  : ((unit ->[local many] unit) +[unique local] unit)
in
((fun _ => sum_left)
 : (unit ->[local once] ((unit ->[local many] unit) +[unique local] unit)))
> (unit ->[a=a3 l=l2 p=p2] ((unit ->[a=a2 l=l1 p=p1] unit) +[u=u1 a=a1] unit))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}
>   p2 ∈ {non-portable, portable}
>   l2 ∈ {many, never, once}
>   a3 ∈ {global, local, regional}
> mode rels
>   (a3,a2) ∉ {(regional,global), (local,global), (local,regional)}
>   (l2,l1) ∉ {(once,many), (never,many), (never,once)}
>   (p2,p1) ∉ {(non-portable,portable)}

(* once closure fails via sum.right path *)
let sum_right =
  (right(((fun x => x) : (unit ->[local many] unit))))
  : (unit +[unique local] (unit ->[local many] unit))
in
((fun _ => sum_right)
 : (unit ->[local once] (unit +[unique local] (unit ->[local many] unit))))
> (unit ->[a=a3 l=l2 p=p2] (unit +[u=u1 a=a2] (unit ->[a=a1 l=l1 p=p1] unit)))
> mode vars
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a1 ∈ {global, local, regional}
>   a2 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p2 ∈ {non-portable, portable}
>   l2 ∈ {many, never, once}
>   a3 ∈ {global, local, regional}
> mode rels
>   (a3,a1) ∉ {(regional,global), (local,global), (local,regional)}
>   (l2,l1) ∉ {(once,many), (never,many), (never,once)}
>   (p2,p1) ∉ {(non-portable,portable)}

(* once closure fails via nested pair path chain *)
let nested_pair =
  ((unit,
    ((fun x => x) : (unit ->[local many] unit)))
   : (unit *[unique local] (unit ->[local many] unit)))
in
let bundle =
  (nested_pair, unit)
  : ((unit *[unique local] (unit ->[local many] unit)) *[unique local] unit)
in
((fun _ => bundle)
 : (unit
    ->[local once]
    ((unit *[unique local] (unit ->[local many] unit)) *[unique local] unit)))
> (unit ->[a=a4 l=l2 p=p2] ((unit *[u=u2 a=a3] (unit ->[a=a2 l=l1 p=p1] unit)) *[u=u1 a=a1] unit))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}
>   a3 ∈ {global, local, regional}
>   u2 ∈ {aliased, unique}
>   p2 ∈ {non-portable, portable}
>   l2 ∈ {many, never, once}
>   a4 ∈ {global, local, regional}
> mode rels
>   (a4,a2) ∉ {(regional,global), (local,global), (local,regional)}
>   (l2,l1) ∉ {(once,many), (never,many), (never,once)}
>   (p2,p1) ∉ {(non-portable,portable)}

(* once closure fails via nested sum path chain *)
let nested_sum_fn =
  (left(((fun x => x) : (unit ->[local many] unit))))
  : ((unit ->[local many] unit) +[unique local] unit)
in
let bundle =
  (right(nested_sum_fn))
  : (unit +[unique local] ((unit ->[local many] unit) +[unique local] unit))
in
((fun _ => bundle)
 : (unit
    ->[local once]
    (unit +[unique local] ((unit ->[local many] unit) +[unique local] unit))))
> (unit ->[a=a4 l=l2 p=p2] (unit +[u=u2 a=a3] ((unit ->[a=a2 l=l1 p=p1] unit) +[u=u1 a=a1] unit)))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}
>   a3 ∈ {global, local, regional}
>   u2 ∈ {aliased, unique}
>   p2 ∈ {non-portable, portable}
>   l2 ∈ {many, never, once}
>   a4 ∈ {global, local, regional}
> mode rels
>   (a4,a2) ∉ {(regional,global), (local,global), (local,regional)}
>   (l2,l1) ∉ {(once,many), (never,many), (never,once)}
>   (p2,p1) ∉ {(non-portable,portable)}

(* many closure succeeds on nested pair with once-qualified function *)
let nested_pair_once =
  ((unit,
    ((fun x => x) : (unit ->[local once] unit)))
   : (unit *[unique local] (unit ->[local once] unit)))
in
let bundle =
  (nested_pair_once, unit)
  : ((unit *[unique local] (unit ->[local once] unit)) *[unique local] unit)
in
((fun _ => bundle)
 : (unit
    ->[local many]
    ((unit *[local] (unit ->[local once] unit)) *[local] unit)))
> (unit ->[a=a4 l=l2 p=p2] ((unit *[u=u2 a=a3] (unit ->[a=a2 l=l1 p=p1] unit)) *[u=u1 a=a1] unit))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}
>   a3 ∈ {global, local, regional}
>   u2 ∈ {aliased, unique}
>   p2 ∈ {non-portable, portable}
>   l2 ∈ {many, never, once}
>   a4 ∈ {global, local, regional}
> mode rels
>   (a4,a2) ∉ {(regional,global), (local,global), (local,regional)}
>   (l2,l1) ∉ {(once,many), (never,many), (never,once)}
>   (p2,p1) ∉ {(non-portable,portable)}

(* many closure succeeds on nested sum with once-qualified function *)
let nested_sum_once =
  (left(((fun x => x) : (unit ->[local once] unit))))
  : ((unit ->[local once] unit) +[unique local] unit)
in
let bundle =
  (right(nested_sum_once))
  : (unit +[unique local] ((unit ->[local once] unit) +[unique local] unit))
in
((fun _ => bundle)
 : (unit
    ->[local many]
    (unit +[local] ((unit ->[local once] unit) +[local] unit))))
> (unit ->[a=a4 l=l2 p=p2] (unit +[u=u2 a=a3] ((unit ->[a=a2 l=l1 p=p1] unit) +[u=u1 a=a1] unit)))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}
>   a3 ∈ {global, local, regional}
>   u2 ∈ {aliased, unique}
>   p2 ∈ {non-portable, portable}
>   l2 ∈ {many, never, once}
>   a4 ∈ {global, local, regional}
> mode rels
>   (a4,a2) ∉ {(regional,global), (local,global), (local,regional)}
>   (l2,l1) ∉ {(once,many), (never,many), (never,once)}
>   (p2,p1) ∉ {(non-portable,portable)}

(* once closure fails when capturing a many-closure as a value *)
let unique_pair = ((unit, unit) : (unit *[unique local] unit)) in
let inner =
  ((fun _ => unique_pair) : (unit ->[local many] (unit *[local] unit)))
in
((fun _ => inner)
 : (unit ->[local once] (unit ->[local many] (unit *[local] unit))))
> (unit ->[a=a3 l=l2 p=p2] (unit ->[a=a2 l=l1 p=p1] (unit *[u=u1 a=a1] unit)))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}
>   p2 ∈ {non-portable, portable}
>   l2 ∈ {many, never, once}
>   a3 ∈ {global, local, regional}
> mode rels
>   (a3,a2) ∉ {(regional,global), (local,global), (local,regional)}
>   (l2,l1) ∉ {(once,many), (never,many), (never,once)}
>   (p2,p1) ∉ {(non-portable,portable)}

(* many closure succeeds when capturing a once-closure as a value *)
let unique_pair = ((unit, unit) : (unit *[unique local] unit)) in
let inner =
  ((fun _ => unique_pair) : (unit ->[local once] (unit *[unique local] unit)))
in
((fun _ => inner)
 : (unit ->[local many] (unit ->[local once] (unit *[unique local] unit))))
> (unit ->[a=a3 l=l2 p=p2] (unit ->[a=a2 l=l1 p=p1] (unit *[u=u1 a=a1] unit)))
> mode vars
>   a1 ∈ {global, local, regional}
>   u1 ∈ {aliased, unique}
>   p1 ∈ {non-portable, portable}
>   l1 ∈ {many, never, once}
>   a2 ∈ {global, local, regional}
>   p2 ∈ {non-portable, portable}
>   l2 ∈ {many, never, once}
>   a3 ∈ {global, local, regional}
> mode rels
>   (a3,a2) ∉ {(regional,global), (local,global), (local,regional)}
>   (l2,l1) ∉ {(once,many), (never,many), (never,once)}
>   (p2,p1) ∉ {(non-portable,portable)}
