borrow x = unit for y = x in y
> unit

let a = (unit, unit) in let! (q,r) = a in (q,r)
> (unit *[u=u1 a=a1 r=r1] unit)
> mode vars
>   r1 ∈ [r0, rinf]
>   a1 ∈ {borrowed, global, local, regional}
>   u1 ∈ {aliased, unique}

let fst = (fun p => let (x,y) = p in x) in
borrow a = (unit, unit) for b = fst a in let! (q,r) = a in (b, q)
> (unit *[u=u1 a=a1 r=r1] unit)
> mode vars
>   r1 ∈ [r0, rinf]
>   a1 ∈ {borrowed, global, local, regional}
>   u1 ∈ {aliased, unique}

(* We can even borrow stack allocated data that contains heap allocated data! *)
let fst = (fun p => let (x,y) = p in x) in
let p = (unit, unit) in
borrow a = $(unit, p) for b = fst a in let! (q,r) = a in (b, q)
> (unit *[u=u1 a=a1 r=r1] unit)
> mode vars
>   r1 ∈ [r0, rinf]
>   a1 ∈ {borrowed, global, local, regional}
>   u1 ∈ {aliased, unique}

(* This ought to be OK but is rejected. Related to Leo's ideas? *)
let fst = (fun p => let (x,y) = p in x) in
let p = (unit, unit) in
borrow a = $(p, unit) for b = fst a in let! (q,r) = a in (b, q)
> error: mode solver detected areality inconsistency

borrow a = (unit, unit) for b = a in let! (q,r) = a in (b, q)
> error: mode solver detected areality inconsistency

let x = (unit, unit) in
borrow a = x for b = (let (q,r) = a in q) in let! (q,r) = a in (b,a)
> error: mode solver detected uniqueness inconsistency

let x = (unit, unit) in
region 
  let y = $(x,x) in
  let (a,b) = y in a
> (unit *[u=aliased a=global r=r1] unit)
> mode vars
>   r1 ∈ [r0, rinf]
